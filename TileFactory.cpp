#include "TileFactory.hpp"


TileFactory::~TileFactory()
{
	/* delete all remaining objects */
	reset();
}

void TileFactory::loadTexture(const sf::Image & image, const sf::IntRect & area = sf::IntRect())
{
	texture.loadFromImage(image,area);
}

Tile * TileFactory::generate(int dur, sf::Vector2f pos)
{
	Tile * p = new Tile(dur,pos,texture);
	active.addItem(p);
	return p;
}

void TileFactory::reset()
{
	Tile * p;
	List<Tile>::Iterator iter = active.getIterator();
	while (iter.hasNext())
	{
		p = iter.next();
		active.removeItem(p);
		delete p;
	}
}

/* delete all tiles currently in the TileDeadState */
void TileFactory::filterDead()
{
	Tile * p;
	List<Tile>::Iterator iter = active.getIterator();
	while (iter.hasNext())
	{
		p = iter.next();
		if (p -> isDead())
		{
			active.removeItem(p);
			delete p;
		}
	}
}

/* update all tiles generated by factory */
void TileFactory::update()
{
	List<Tile>::Iterator iter = active.getIterator();
	while (iter.hasNext())
		iter.next() -> update();
}

/* draw all tiles generated by factory */
void TileFactory::draw(sf::RenderWindow & window)
{
	List<Tile>::Iterator iter = active.getIterator();
	while (iter.hasNext())
		iter.next() -> draw(window);
}

/* pass event to all tiles generated by factory */
void TileFactory::handleEvent(sf::Event event)
{
	List<Tile>::Iterator iter = active.getIterator();
	while (iter.hasNext())
		iter.next() -> handleEvent(event);
}
