#include "TileFactory.hpp"


TileFactory::~TileFactory()
{
	/* delete all remaining objects */
	reset();
}

void TileFactory::loadTexture(const sf::Image & spritesheet)
{
	texture.loadFromImage(spritesheet,sf::IntRect(0,40,160,80));
}

Tile * TileFactory::generate(int dur, sf::Vector2f pos, int type)
{
	Tile * t = new Tile(dur,pos,texture,sf::IntRect((type/2)*80,(type%2)*40,80,40),type);
	active.addItem(t);
	return t;
}


Tile * TileFactory::generate(string line)
{
	int type, dur;
	sf::Vector2f pos;
	std::stringstream ss(line);
	ss >> type >> dur;
	ss >> pos.x >> pos.y;

	Tile * t = new Tile(dur,pos,texture,sf::IntRect((type/2)*80,(type%2)*40,80,40),type);
	active.addItem(t);
	return t;
}

Tile * TileFactory::generate(Tile & tile)
{
	Tile * t = new Tile(tile);
	active.addItem(t);
	return t;
}

void TileFactory::reset()
{
	List<Tile>::Iterator iter = active.getIterator();
	while (iter.hasNext())
	{
		delete iter.next();
		iter.removeLastItem();
	}
}

/* delete all tiles currently in the TileDeadState */
unsigned int TileFactory::filterDead()
{
	unsigned int total = 0;
	List<Tile>::Iterator iter = active.getIterator();
	while (iter.hasNext())
		if (iter.next() -> isDead())
		{
			delete iter.removeLastItem();
			total++;
		}
	return total;
}

/* update all tiles generated by factory */
void TileFactory::update(float time)
{
	List<Tile>::Iterator iter = active.getIterator();
	while (iter.hasNext())
		iter.next() -> update(time);
}

/* draw all tiles generated by factory */
void TileFactory::draw(sf::RenderWindow & window)
{
	List<Tile>::Iterator iter = active.getIterator();
	while (iter.hasNext())
		iter.next() -> draw(window);
}

/* pass event to all tiles generated by factory */
void TileFactory::handleEvent(sf::Event event)
{
	List<Tile>::Iterator iter = active.getIterator();
	while (iter.hasNext())
		iter.next() -> handleEvent(event);
}
